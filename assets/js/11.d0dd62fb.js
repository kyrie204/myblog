(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{894:function(e,r,o){"use strict";o.r(r);var l=o(119),t=Object(l.a)({},(function(){var e=this,r=e.$createElement,o=e._self._c||r;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h4",{attrs:{id:"mvx框架模式-mvc-mvp-mvvm"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#mvx框架模式-mvc-mvp-mvvm"}},[e._v("#")]),e._v(" MVX框架模式：MVC+MVP+MVVM")]),e._v(" "),o("p",[e._v("1.MVC:")]),e._v(" "),o("blockquote",[o("p",[e._v("Model(模型)+View(视图)+controller(控制器)，主要是基于分层的目的，让彼此的职责分开。\nView通过Controller来和Model联系，Controller是View和Model的协调者，View和Model不直接联系，基本联系都是单向的。\n用户User通过控制器Controller来操作模板Model从而达到视图View的变化。\n"),e._v("\n2.MVP:\n是从MVC模式演变而来的，都是通过Controller/Presenter负责逻辑的处理+Model提供数据+View负责显示。\n在MVP中，Presenter完全把View和Model进行了分离，主要的程序逻辑在Presenter里实现。\n并且，Presenter和View是没有直接关联的，是通过定义好的接口进行交互，从而使得在变更View的时候可以保持Presenter不变。")])]),e._v(" "),o("p",[e._v("3.MVVM：")]),e._v(" "),o("blockquote",[o("p",[e._v("MVVM是把MVC里的Controller和MVP里的Presenter改成了ViewModel。Model+View+ViewModel。\nView的变化会自动更新到ViewModel,ViewModel的变化也会自动同步到View上显示。\n这种自动同步是因为ViewModel中的属性实现了Observer，当属性变更时都能触发对应的操作。")])]),e._v(" "),o("p",[e._v("MVVM模式的框架有：AngularJS+Vue.js")])])}),[],!1,null,null,null);r.default=t.exports}}]);